# BSidesSF CTF 2021

![CTFtime Weight: 24.12](https://img.shields.io/badge/CTFtime%20Weight-24.12-critical) ![Teams Participated: 240](https://img.shields.io/badge/Teams%20Participated-240-informational)

**Sat, 06 March 2021, 20:00 UTC — Mon, 08 March 2021, 22:00 UTC**

```
Welcome to BSidesSF CTF 2021!

This year's CTF will run from Saturday, March 6th 12:00 PST to Monday, March 8th 14:00 PST.

The prizes (an Amazon gift card) for the winning teams are,

    1st - $1500
    2nd - $750
    3rd - $250
```

[![https://ctftime.org/event/1299](https://img.shields.io/badge/CTFtime-white?logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABYUlEQVR42pxTTUtCQRQ9973xSZbiTgghCNu0sidu2vcDWrjpJ7Zu3TqILAjaVeu2gYqWczvzhVZi6cCduY+Zc+6Z8+6IquJWDhVbDvNyIJW+qqAtClnacXmeTjGyFWieMRb4oAJ4Eik2VuK40d9/JVsh0BlJWiTRzQji4BVanN9IcqzbEHgOgrk8CfLev0gynXO2iFPESE8wvyMJv836MDvNGm0kaEIxtsqQIKVeArOhoHmyVolplx1gzOyIwBFjwvNjqhmhAkdd+8sDjaanG4So4vl+ik6pqMl3j9aamPnmKPBIcJcm7snvzknD2h8EvtOyKm6GU5yWESwrRFOF1bhHEz0wgAtcE3zGyvXYt9mK/vWVJaxs3qBAWPmKss8JbjighAIiizdg0ypBgf9b1ito4PLhHRddxS5PmywQ5MtEWBjtgM74ufhc3HPGgC8xXcXEV5giEdilcM33GfIvAQYAhHKA5j9Rx1UAAAAASUVORK5CYII=)](https://ctftime.org/event/1299)

## Challenges

- [ϕ-Corps Infiltration](#ϕ-corps-infiltration) ![Crypto](https://img.shields.io/badge/Crypto-blue)
- [Glitch in the matrix](#glitch-in-the-matrix) ![Forensics](https://img.shields.io/badge/Forensics-orange)
- [Great key hunt](#great-key-hunt) ![Forensics](https://img.shields.io/badge/Forensics-orange) ![RE](https://img.shields.io/badge/RE-red)
- [Hack The ______!](#hack-the-______) ![101](https://img.shields.io/badge/101-yellow)
- [Hashcrack 101](#hashcrack-101) ![101](https://img.shields.io/badge/101-yellow) ![Crypto](https://img.shields.io/badge/Crypto-blue)
- [I am not here](#i-am-not-here)
- [In The Zone](#in-the-zone) ![Net](https://img.shields.io/badge/Net-green)
- [layers.txt](#layerstxt) ![101](https://img.shields.io/badge/101-yellow) ![Forensics](https://img.shields.io/badge/Forensics-orange)
- [Net Matroyshka](#net-matroyshka) ![1337](https://img.shields.io/badge/1337-red) ![Forensics](https://img.shields.io/badge/Forensics-orange) ![Net](https://img.shields.io/badge/Net-green)
- [Résumé](#résumé) ![101](https://img.shields.io/badge/101-yellow) ![Forensics](https://img.shields.io/badge/Forensics-orange)
- [Shout into Void](#shout-into-void) ![Cloud](https://img.shields.io/badge/Cloud-skyblue)
- [Thin Mint](#thin-mint) ![101](https://img.shields.io/badge/101-yellow) ![Web](https://img.shields.io/badge/Web-brightgreen)
- [Unidecode](#unidecode) ![101](https://img.shields.io/badge/101-yellow) ![Forensics](https://img.shields.io/badge/Forensics-orange)
- [Whole New Me](#whole-new-me) ![Cloud](https://img.shields.io/badge/Cloud-skyblue)
- [Xoray](#xoray) ![101](https://img.shields.io/badge/101-yellow) ![Crypto](https://img.shields.io/badge/Crypto-blue)

## To Do

- [ ] Charge Tracker ![Mobile](https://img.shields.io/badge/Mobile-green) ![RE](https://img.shields.io/badge/RE-red)
- [ ] CSP 1 ![Web](https://img.shields.io/badge/Web-brightgreen)
- [ ] CSP 2 ![Recharge](https://img.shields.io/badge/Recharge-yellow) ![Web](https://img.shields.io/badge/Web-brightgreen)
- [ ] CuteSrv ![Web](https://img.shields.io/badge/Web-brightgreen)
- [ ] denouement.png ![Forensics](https://img.shields.io/badge/Forensics-orange)
- [ ] Hangman Battle Royale ![Crypto](https://img.shields.io/badge/Crypto-blue)
- [ ] Higher Hurdles ![101](https://img.shields.io/badge/101-yellow) ![Recharge](https://img.shields.io/badge/Recharge-yellow) ![Web](https://img.shields.io/badge/Web-brightgreen)
- [ ] Message Store ![Mobile](https://img.shields.io/badge/Mobile-green) ![RE](https://img.shields.io/badge/RE-red)
- [ ] PermCoin - Starter Attack ![101](https://img.shields.io/badge/101-yellow) ![Crypto](https://img.shields.io/badge/Crypto-blue)
- [ ] Pwnzoo ![101](https://img.shields.io/badge/101-yellow) ![Pwn](https://img.shields.io/badge/Pwn-red)
- [ ] Relaunch ![RE](https://img.shields.io/badge/RE-red) ![Recharge](https://img.shields.io/badge/Recharge-yellow) ![Win](https://img.shields.io/badge/Win-purple)
- [ ] Reverseme ![101](https://img.shields.io/badge/101-yellow) ![Pwn](https://img.shields.io/badge/Pwn-red)
- [ ] Reverseme 2 ![101](https://img.shields.io/badge/101-yellow) ![Pwn](https://img.shields.io/badge/Pwn-red)
- [ ] Ropme ![Pwn](https://img.shields.io/badge/Pwn-red)
- [ ] Runme ![101](https://img.shields.io/badge/101-yellow) ![Pwn](https://img.shields.io/badge/Pwn-red)
- [ ] Runme2 ![101](https://img.shields.io/badge/101-yellow) ![Pwn](https://img.shields.io/badge/Pwn-red)
- [ ] Runme3 ![Pwn](https://img.shields.io/badge/Pwn-red)
- [ ] Tapesplice ![Forensics](https://img.shields.io/badge/Forensics-orange)

---

## ϕ-Corps Infiltration

![Solves: 21](https://img.shields.io/badge/Solves-21-brightgreen) ![Points: 192](https://img.shields.io/badge/Points-192-blue)

**Challenge Category**

![Crypto](https://img.shields.io/badge/Crypto-blue)

**Challenge Description**

```
In the year 25521 only a select few are allowed to generate their own primes. Can you infiltrate the ϕ-Corps and decrypt Agent 7's message?

nc -v phicorps-26aed53a.challenges.bsidessf.net 25519

(author: symmetric)
```

**Flag**

```
CTF{omg_rsa_destroyyyyyeeeeddddd}
```

### Summary

You are given a private key which shares the same public modulus, `n`, as the key used to encrypt the message. If two keys have the same `n`, it means the primes `p` and `q` are also the same. This allows you to easily recover the private exponent, `d`, and decrypt the message using basic RSA functions.

### Solution

For this challenge, we are provided with our own private key, `Agent 7`'s public exponent, and a message which was encrypted with `Agent 7`'s key. To get the flag, we have to decrypt the message and send it back to the server.

When we connect to the server, we get this banner message:

```
Welcome Agent 65537!

Your deep cover has come through at last! You've been appointed to ϕ-Corps.
You've been given the designation Agent 65537 by the Corps.

The ϕ-Corps issues cryptographic keys to all their agents. This is our
chance to intercept messages for Agent 7.

As you know, after the great prime war of 25519 the Corps determined
that prime generation was too great of a risk for their agents. As
such, the ϕ-Corps now uses a shared modulus for all their agents with
a prime factorization known only to a select few at the Corps. The
Corps generates a random encrypting exponent and uses their knowledge
of the prime factorization of the shared modulus to derrive a
decrypting exponent. They issue such a pair of exponents to each of
their agents.

We've arranged for the Corps to issue you a keypair. We've intercepted
the public key for Agent 7 and you should be able to get their public key.
We need you to decrypt the message using your new appointment.
```

The important takeaway from the banner is that everyone uses a ***shared modulus***. Why does this matter? Well in RSA, if two keys have the same public modulus, `n`, that means they also share the same primes, `p` and `q`. This is important because that means by having our private key, we basically have their private key as well.

The way we decrypt things in RSA is by using this equation:\
`m = c^d % n`

So in order to decrypt the message, we need to calculate the value for `Agent 7`'s `d`, which is calculated using these equation:\
`ϕ(n) = (p-1)*(q-1)`\
`d = modinv(e, ϕ(n))`

Alright, so now that we know what to do, lets get started. First we have to retrieve the values given to us by the server:

```python
def get_values(conn):
    conn.recvuntil(b'public modulus: ')
    n = int(conn.recvuntil(b'\n'))
    conn.recvuntil(b'Your public encryption exponent: ')
    e1 = int(conn.recvuntil(b'\n'))
    conn.recvuntil(b'Your private decryption exponent: ')
    d1 = int(conn.recvuntil(b'\n'))

    conn.recvuntil(b'public encryption exponent is ')
    e2 = int(conn.recvuntil(b'\n'))
    conn.recvuntil(b'Agent 7 was ')
    c = int(conn.recvuntil(b'\n'))

    key1 = {'n': n,
            'e': e1,
            'd': d1
           }
    key2 = {'n': n,
            'e': e2
           }
    return key1, key2, c
```

Since we don't have the same `e`, we can't just decrypt the message with our private key, so we'll have to have to recalculate `d` using `Agent 7`'s `e`. Unfortunately, we aren't given the values of `p` and `q`. However, we can easily recover the primes with our private key using basic RSA functions. This is my script to recover the primes, which was derived from Appendix C of [Recommendation for Pair-Wise Key Establishment Using Integer Factorization Cryptography](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Br2.pdf):

```python
def gcd(a, b):
    while a:
        a, b = b%a, a
    return b

def recover_primes(n, e, d):
    m = d*e-1
    k = m
    while k%2 == 0:
        k >>= 1
    g = 2
    while g <= 100:
        r = k
        while r < m:
            y = pow(g, r, n)
            if y != 1 and y != (n-1) and pow(y, 2, n) == 1:
                p = gcd(n, y-1)
                assert (n % p) == 0 and p != 1 and p != n
                q = n//p
                return p, q
            r *= 2
        g += 1
    raise ValueError("Unable to recover primes.")
```

Now we just run this function with our private key values and we get `p` and `q`. From there we just simply calculate the value of `Agent 7`'s `d` and decrypt the message:

```python
def egcd(a, b):
    x, x1 = 1, 0
    y, y1 = 0, 1
    while b != 0:
        q, a, b = a//b, b, a%b
        x, x1 = x1, x-q*x1
        y, y1 = y1, y-q*y1
    return (a, x, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise ValueError('Modular inverse does not exist.')
    else:
        return x % m

def decrypt_msg(key1, key2, c):
    p, q = recover_primes(key1['n'], key1['e'], key1['d'])
    phin = (p-1) * (q-1)
    key2['d'] = modinv(key2['e'], phin)
    m = pow(c, key2['d'], key2['n'])
    return m
```

Now we put it all together into one [script](files/phi-corps_infiltration/phicorps.py) to get the flag:

```python
#!/usr/bin/env python3
from pwn import *


context.log_level = 'warn'
def connect():
    host = 'phicorps-26aed53a.challenges.bsidessf.net'
    port = 25519
    r = remote(host, port)
    return r

def get_values(conn):
    conn.recvuntil(b'public modulus: ')
    n = int(conn.recvuntil(b'\n'))
    conn.recvuntil(b'Your public encryption exponent: ')
    e1 = int(conn.recvuntil(b'\n'))
    conn.recvuntil(b'Your private decryption exponent: ')
    d1 = int(conn.recvuntil(b'\n'))

    conn.recvuntil(b'public encryption exponent is ')
    e2 = int(conn.recvuntil(b'\n'))
    conn.recvuntil(b'Agent 7 was ')
    c = int(conn.recvuntil(b'\n'))

    key1 = {'n': n,
            'e': e1,
            'd': d1}
    key2 = {'n': n,
            'e': e2}
    return key1, key2, c

def egcd(a, b):
    x, x1 = 1, 0
    y, y1 = 0, 1
    while b != 0:
        q, a, b = a//b, b, a%b
        x, x1 = x1, x-q*x1
        y, y1 = y1, y-q*y1
    # gcd, coefficient_a, coefficient_b
    return (a, x, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise ValueError('Modular inverse does not exist.')
    else:
        return x % m

def recover_primes(n, e, d):
    m = d*e-1
    k = m
    while k%2 == 0:
        k >>= 1
    g = 2
    while g <= 100:
        r = k
        while r < m:
            y = pow(g, r, n)
            if y != 1 and y != (n-1) and pow(y, 2, n) == 1:
                p, *_ = egcd(n, y-1)
                assert (n % p) == 0 and p != 1 and p != n
                q = n//p
                return p, q
            r *= 2
        g += 1
    raise ValueError("Unable to recover primes.")

def decrypt_msg(key1, key2, c):
    p, q = recover_primes(key1['n'], key1['e'], key1['d'])
    phin = (p-1) * (q-1)
    key2['d'] = modinv(key2['e'], phin)
    m = pow(c, key2['d'], key2['n'])
    return m


if __name__ == '__main__':
    r = connect()
    key1, key2, c = get_values(r)
    m = decrypt_msg(key1, key2, c)
    r.recvuntil(b'What was the message sent to Agent 7? ')
    r.sendline(str(m))
    flag = r.recvall()
    print(flag.strip().decode())

```

```bash
$ ./phicorps.py
CTF{omg_rsa_destroyyyyyeeeeddddd}
```

### References

[Recommendation for Pair-Wise Key Establishment Using Integer Factorization Cryptography](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Br2.pdf)

---

## Glitch in the matrix

![Solves: 17](https://img.shields.io/badge/Solves-17-brightgreen) ![Points: 314](https://img.shields.io/badge/Points-314-blue)

**Challenge Category**

![Forensics](https://img.shields.io/badge/Forensics-orange)

**Challenge Description**

```
It's either deja vu or this JPEG is corrupt.

(author: symmetric)
```

**Challenge Files**

[glitchinthematrix.jpg](files/glitch_in_the_matrix/glitchinthematrix.jpg)

**Flag**

```
CTF{we_need_bits_lots_of_bits}
```

### Summary

Modify the DQT segment in the jpg to recover the flag. Replace both tables in [glitchinthematrix.jpg](files/glitch_in_the_matrix/glitchinthematrix.jpg) with all `01`s for the clearest image.

### Solution

We start off by looking at the challenge file:

![glitchinthematrix.jpg](files/glitch_in_the_matrix/glitchinthematrix.jpg)

There's a big clear hint pointing towards the DQT segment. After [reading](https://en.wikibooks.org/wiki/JPEG_-_Idea_and_Practice/The_header_part) up on the DQT segment, we find out that the table consists of a 64 byte chunk that determines how the image maps out the color. Unfortunately, there's no way you can recover the original DQT (at least none that I know of), so we're left with just putting in random values and hoping for the best.

Lucky for us, [010 Editor](https://www.sweetscape.com/010editor/) has a template to parse images for us:

![glitch_in_the_matrix1.jpg](img/screenshots/glitch_in_the_matrix1.jpg)

Next I just loaded a ton of random images and replaced the DQT segment from our challenge file with the one from the random image. After a couple tries, I ended up with this:

![glitchinthematrix_flag.jpg](files/glitch_in_the_matrix/glitchinthematrix-flag.jpg)

---

## Great key hunt

![Solves: 69](https://img.shields.io/badge/Solves-69-brightgreen) ![Points: 101](https://img.shields.io/badge/Points-101-blue)

**Challenge Category**

![Forensics](https://img.shields.io/badge/Forensics-orange) ![RE](https://img.shields.io/badge/RE-red)

**Challenge Description**

```
We've found an encrypted flag, but the encrypter crashed and left us a core file -- can you use that to find the flag?

(author: matir)
```

**Challenge Files**

[core](files/great_key_hunt/core)\
[flag.txt.enc](files/great_key_hunt/flag.txt.enc)\
[keyhunt](files/great_key_hunt/keyhunt)\
[Makefile](files/great_key_hunt/Makefile)

**Flag**

```
CTF{core_secrets_are_still_secrets}
```

### Solution

Strings.

```bash
$ egrep -aor 'CTF\{.+\}'
core:CTF{core_secrets_are_still_secrets}
```

---

## Hack The ______!

![Solves: 98](https://img.shields.io/badge/Solves-98-brightgreen) ![Points: 1](https://img.shields.io/badge/Points-1-blue)

**Challenge Category**

![101](https://img.shields.io/badge/101-yellow)

**Challenge Description**

```
I think you know what to do here.

(Flag is not in CTF{} format.)
```

**Flag**

```
Planet
```

### Solution

Reference to cult classic movie, [Hackers](https://www.imdb.com/title/tt0113243/).

![Hack_The_Planet](img/media/hack_the_planet.jpg)

### References

[Hackers](https://www.imdb.com/title/tt0113243/)

---

## Hashcrack 101

![Solves: 55](https://img.shields.io/badge/Solves-55-brightgreen) ![Points: 101](https://img.shields.io/badge/Points-101-blue)

**Challenge Category**

![101](https://img.shields.io/badge/101-yellow) ![Crypto](https://img.shields.io/badge/Crypto-blue)

**Challenge Description**

```
I've got some simple hashes for you to crack. To get your flag, concatenate the plaintext of each hash with underscores and surround in CTF{}. For example, CTF{plaintext01_plaintext02}.

(author: matir)
```

**Challenge Files**

[hashes.txt](files/hashcrack_101/hashes.txt)

**Flag**

```
CTF{drink_all_the_booze_hack_all_the_things_dedicated_to_all_the_hackers}
```

### Summary

Use `hashcat` to decrypt the passwords using an [english dictionary wordlist](files/hashcrack_101/words_alpha.txt).

### Solution

For this challenge, we are given a list of hashes that we have to crack. First things first, we have to know what type of hashes we are working with. We can do that by using [hashid](https://github.com/psypanda/hashID).

```bash
$ hashid hashes.txt
--File 'hashes.txt'--
Analyzing 'J2KpcoAbuql8U'
[+] DES(Unix)
[+] Traditional DES
[+] DEScrypt
...
Analyzing '$1$7TBqF/dR$no7Ql63c.FhX1Udl7t1Ws.'
[+] MD5 Crypt
[+] Cisco-IOS(MD5)
[+] FreeBSD MD5
...
Analyzing '$6$cBqA5xLZVRriv.u/$swKMycBkvyi2RhL6gHvxxwqnWobOE4pRBkyH.hHOA5xyr2nttM5eOLDMjxyWDCL.ngbQ2T47bBwkMUkuB/VUo1'
[+] SHA-512 Crypt
...
--End of file 'hashes.txt'--
```

So now that we know what types of hashes we are working with, we have to find the corresponding hash modes to use with `hashcat`.

```bash
$ hashcat -h | egrep -i "(DEScrypt|MD5Crypt|SHA512Crypt)"
    500 | md5crypt, MD5 (Unix), Cisco-IOS $1$ (MD5)        | Operating System
   1500 | descrypt, DES (Unix), Traditional DES            | Operating System
   1800 | sha512crypt $6$, SHA512 (Unix)                   | Operating System
```

Now we can start cracking passwords. A good wordlist to start out with is `rockyou.txt`.

```bash
$ hashcat -m 1500 hashes.txt /usr/share/wordlists/rockyou.txt
...
J2KpcoAbuql8U:drink
YYsBUtwzeoJqM:booze
MZLzIKG.XL9GE:the
...
Recovered........: 3/4 (75.00%) Digests, 3/4 (75.00%) Salts
...
```

Looks like we only recovered 3/4 of the descrypt hashes with `rockyou`. However, if we look at the passwords we did recover, we can see that they seem to follow a general theme of lowercase english words. Let's try again with an [english dictionary wordlist](files/hashcrack_101/words_alpha.txt).

```bash
$ hashcat -m 1500 hashes.txt /usr/share/wordlists/words-alpha.txt
...
PU/dGdAVlBvMw:all
...
```

Cool. Now we rinse and repeat for the other two hash types.

```bash
$ hashcat -m 500 hashes.txt /usr/share/wordlists/words_alpha.txt
...
$1$06bhZHCs$iNkfXQwwkMzXGxSfQTyw6/:all
$1$gbigI1Qh$1eGGYwYi2r4zdrgh8Xzyo0:dedicated
$1$7TBqF/dR$no7Ql63c.FhX1Udl7t1Ws.:hack
$1$n7GL0.6g$pjv5N8FZAIpdGmbTHGRB30:things
$1$uymtXSqy$BR/ZZfPWhoX0wntRq3QtO0:the
...
```

```bash
$ hashcat -m 1800 hashes.txt /usr/share/wordlists/words_alpha.txt
...
$6$tn8ELZASfBa0oMmE$142wF.JRnWgaOSsyXh/WCiuc7ZKWquN7StAA6X3lbUlM.G0nmfxDM.TrPX7e19lvltTeDUXXoNTJfDwzPBE2d.:all
$6$sfnr6Bk3vgABiniV$YLvIcvqmqiYGcLy8ZwRScnHHhKs2mk7ixK9BGTQMp.1JlWnb06LE9nImpWJgNuCm9tWVcWJjxmyXd.xOsye2v0:hackers
$6$cBqA5xLZVRriv.u/$swKMycBkvyi2RhL6gHvxxwqnWobOE4pRBkyH.hHOA5xyr2nttM5eOLDMjxyWDCL.ngbQ2T47bBwkMUkuB/VUo1:to
$6$EUPTdRD4oHlripYb$EW4KkzaSx.M0UXXg1GvHXb3D.UNPBuAVtmAr.NO2GzcDGFpDrLXmcJ9EqBuyGLerbVI/hXiKrpJWbXf4zAQTJ1:the
...
```

Now that we've cracked all the hashes, we just need to put them together in the same order as in the file and wrap it in the flag format.

```
CTF{drink_all_the_booze_hack_all_the_things_dedicated_to_all_the_hackers}
```

---

## I am not here

![Solves: 9](https://img.shields.io/badge/Solves-9-brightgreen) ![Points: 1](https://img.shields.io/badge/Points-1-blue)

**Challenge Description**

```
Thank you for tuning into BSidesSF 2021!
```

**Flag**

```
CTF{i_am_not_here}
```

### Solution

Based on the name of the challenge and the description, we can probably assume that the flag is hidden in [BSidesSF video feed](https://youtu.be/ljBju-TONss?list=PLbZzXF2qC3RvWn6Nne_Jj8IkLXZP3tgE6&t=6240) during one of the breaks.

![i_am_not_here1.jpg](img/screenshots/i_am_not_here1.jpg)

---

## layers.txt

![Solves: 93](https://img.shields.io/badge/Solves-93-brightgreen) ![Points: 101](https://img.shields.io/badge/Points-101-blue)

**Challenge Category**

![101](https://img.shields.io/badge/101-yellow) ![Forensics](https://img.shields.io/badge/Forensics-orange)

**Challenge Description**

```
ASCII. So much ASCII!

(author: symmetric)
```

**Challenge Files**

[layers.txt](files/layers_txt/layers.txt)

**Flag**

```
CTF{morse_was_the_original_binary}
```

### Solution

For this challenge, we are given a file, [layers.txt](files/layers_txt/layers.txt), which contains multiple layers of encoded text. You can decode the data using [CyberChef](https://gchq.github.io/CyberChef/#recipe=From_Binary('Space',8)From_Octal('Space')From_Hex('Auto')From_Base64('A-Za-z0-9%2B/%3D',true)From_Base85('!-u')).

The layers, in order, are:

```
Binary
Octal
Hex
Base64
Base85
```

Decode the text in that order to get the flag.

---

## In The Zone

![Solves: 15](https://img.shields.io/badge/Solves-15-brightgreen) ![Points: 408](https://img.shields.io/badge/Points-408-blue)

**Challenge Category**

![Net](https://img.shields.io/badge/Net-green)

**Challenge Description**

```
I found this old nameserver for BSides CTF from way back, maybe you can get something out of it? I'm not sure, I'm no good with that hacker crap. My friend says it looks like they left the tcp port open.

nc -v in-the-zone-0a12d0c7.challenges.bsidessf.net 53

(author: mandatory and itsc0rg1)
```

**Flag**

```
CTF{DOMAINSAREBACKWARDS}
```

### Solution

Alright, so we're given several clues from the challenge title and description. The title, `In The Zone`, hints towards a zone transfer, and the challenge description mentions there is a tcp port open. Zone transfers use TCP, so that's a good sign. This sounds like a good place to start. Let's attempt to do a zone transfer for `bsidessf.net` using the provided DNS server, `in-the-zone-0a12d0c7.challenges.bsidessf.net`.

```bash
$ dig @in-the-zone-0a12d0c7.challenges.bsidessf.net bsidessf.net AXFR

; <<>> DiG 9.11.5-P4-5.1+b1-Debian <<>> @in-the-zone-0a12d0c7.challenges.bsidessf.net bsidessf.net AXFR
; (1 server found)
;; global options: +cmd
dig: '00---CCC----00.bsidessf.net.' is not a legal IDNA2008 name (string contains forbidden two hyphens pattern), use +noidnout
```

>use +noidnout

Uhhh... Sure... If you say so.

```bash
dig +noidnout @in-the-zone-0a12d0c7.challenges.bsidessf.net bsidessf.net AXFR
```

![in_the_zone1.jpg](img/screenshots/in_the_zone1.jpg)

```bash
dig +noidnout @in-the-zone-0a12d0c7.challenges.bsidessf.net bsidessf.net AXFR > inthezone.txt
```

[inthezone.txt](files/in_the_zone/inthezone.txt)

Nice.

---

## Net Matroyshka

![Solves: 6](https://img.shields.io/badge/Solves-6-brightgreen) ![Points: 883](https://img.shields.io/badge/Points-883-blue)

**Challenge Category**

![1337](https://img.shields.io/badge/1337-red) ![Forensics](https://img.shields.io/badge/Forensics-orange) ![Net](https://img.shields.io/badge/Net-green)

**Challenge Description**

```
We heard you like PCAPs, so we put a PCAP inside your PCAP.

(author: matir)
```

**Challenge Files**

[8.zip](files/net_matroyshka/8.zip)

**Flag**

```
CTF{baby_wireshark_doo_doo_doo_baby_wireshark}
```

### Summary

This challenge consisted of 8 layers of pcaps hidden inside pcaps. Each level required a different technique to extract the file hidden within the network traffic.

[**Level 8:**](#Level-8) Extract [7.zip](files/net_matroyshka/7.zip) from the *HTTP* traffic. Password to the zip can be seen in the HTTP traffic. Password: `goodluck,havefun`

[**Level 7:**](#Level-7) Extract [6.zip](files/net_matroyshka/6.zip) from the *FTP* traffic.

[**Level 6:**](#Level-6) Extract [5.zip](files/net_matroyshka/5.zip) from the *RSYNC* traffic. Four extra bytes are inserted within the zip. Remove the extra bytes `29 0f 00 00` at offset `32768`.

[**Level 5:**](#Level-5) Extract [4.zip](files/net_matroyshka/4.zip) from the *TFTP* traffic. File was transferred in *netascii* mode. Find and replace all instances of `0d 00` with `0d` and `0d 0a` with `0a`.

[**Level 4:**](#Level-4) Extract [3.zip](files/net_matroyshka/3.zip) from the *SMB2* traffic.

[**Level 3:**](#Level-3) Extract [2.pack](files/net_matroyshka/2.pack) from the *Git Smart Protocol* traffic. Unpack the packfile and `checkout` the dangling commit to recover [2.zip](files/net_matroyshka/2.zip).

[**Level 2:**](#Level-2) Extract [1.zip](files/net_matroyshka/1.zip) from the *dnscat2* traffic. The file is broken up into hex-encoded chunks and sent over the network via `dns.cname`, `dns.mx.mail_exchange`, `dns.txt` fields in the DNS responses. Each chunk also contains 9 bytes of overhead data from dnscat2. Remove the overhead bytes and combine the chunks to retrieve the file.

[**Level 1:**](#Level-1) Extract the hex-encoded flag from the *Telnet* traffic. Decode the string to retrieve the flag.

### Solution

#### Level 8

We begin our "20 minute adventure" with [8.zip](files/net_matroyshka/8.zip), which contains `8.pcap`. When we open the pcap in wireshark, we can see a ton of HTTP traffic. While inspecting the TCP streams, we see a `GET` request for `7.zip`. Cool, that looks like what we're after. We can extract the file by going to `File` -> `Export Objects` -> `HTTP...` and selecting `7.zip`. The file was sent twice so there's two copies. Pick either one and click `Save`.

If we take a closer look at the response headers, there is also a field `X-Zip-Password` with the value `goodluck,havefun`. Unzip [7.zip](files/net_matroyshka/7.zip) using the password to get `7.pcap`.

#### Level 7

This next level is pretty straightforward. We can clearly see a FTP file transfer for `6.zip`. We can extract the file by going to `tcp.stream == 1` and opening the TCP stream. Then click the dropdown for `Show and save data as`, change it from `ASCII` to `Raw`, and save the file as [6.zip](files/net_matroyshka/6.zip).

#### Level 6

Next up, we have some RSYNC traffic. When we inspect the TCP stream, we can see the command to transfer `5.zip`, followed by the zip file signature.

![net_matroyshka1.jpg](img/screenshots/net_matroyshka1.jpg)

![net_matroyshka2.jpg](img/screenshots/net_matroyshka2.jpg)

Unfortunately, wireshark does not have any fancy method to extract the file for us, so we're going to have to use some command line sorcery.

Here's the command to extract the [file](files/net_matroyshka/corrupt_5.zip):

```bash
tshark -nr 6.pcap -Y "(frame.number>=22 && frame.number<=32)" -T fields -e rsync.data | xxd -r -p | tail -c +28 > corrupt_5.zip
```

Now all we have to do is unzip the file... Right?

```bash
$ unzip corrupt_5.zip
Archive:  corrupt_5.zip
warning [corrupt_5.zip]:  4 extra bytes at beginning or within zipfile
  (attempting to process anyway)
file #1:  bad zipfile offset (local header sig):  4
  (attempting to re-compensate)
  inflating: 5.pcap
  error:  invalid compressed data to inflate
```

Nope.

But wait... what's this?

> `4 extra bytes at beginning or within zipfile`

I wrote a quick script to remove every 4 bytes in the file and see if anything extracts properly.

```python
#!/usr/bin/env python3
import zipfile


with open('corrupt_5.zip', 'rb') as f:
    data = f.read()

if __name__ == '__main__':
    for i in range(len(data)-4):
        with open('5.zip', 'wb') as f:
            f.write(data[:i]+data[i+4:])

        try:
            z = zipfile.ZipFile('5.zip')
            z.extract('5.pcap')
            print('Successfully extracted 5.pcap')
            print(f'Extra bytes: {data[i:i+4].hex()} at offset {i}')
        except Exception as e:
            pass
```

```bash
$ ./5.py
Successfully extracted 5.pcap
Extra bytes: 290f0000 at offset 32768
```

Aaaaand there it is, [5.zip](files/net_matroyshka/5.zip).

#### Level 5

Next up, we have TFTP. This seems pretty straightforward... or so I thought. First, we extract the file by going to `File` -> `Export Objects` -> `TFTP...` and saving [4.zip](files/net_matroyshka/corrupt_4.zip). However, when we try to unzip it, we get an error:

```bash
$ unzip 4.zip
Archive:  4.zip
warning [4.zip]:  256 extra bytes at beginning or within zipfile
  (attempting to process anyway)
error [4.zip]:  start of central directory not found;
  zipfile corrupt.
  (please check that you have transferred or created the zipfile in the
  appropriate BINARY mode and that you have compiled UnZip properly)
```

This file seems to have an extra 256 bytes, so I tried a modified version of the script from the last level. Surprise, it didn't work. Back to the pcap to look for clues. This looks like standard TFTP traffic except for one thing:

```
Read Request, File: 4.zip, Transfer type: netascii
```

What's netascii, you ask? I have no idea, but [Wikipedia](https://en.wikipedia.org/wiki/Trivial_File_Transfer_Protocol) does. The important takeaway from the wiki page is this:

> Netascii also requires that the end of line marker on a host be translated to the character pair CR LF for transmission, and that any CR must be followed by either a LF or the null.

Okay... So it looks like `netascii` does some shenanigans with control characters.

Let's see if we're on the right track:

```bash
$ xxd -p corrupt_4.zip | tr -d '\n' | egrep -o "(0d0a|0d00)" | wc -l
256
```

There's our extra 256 bytes.

Now to fix the file:

```bash
xxd -p corrupt_4.zip | tr -d '\n' | sed "s/0d0a/0a/g" | sed "s/0d00/0d/g" | xxd -r -p > 4.zip
```

Here's the repaired file: [4.zip](files/net_matroyshka/4.zip).

#### Level 4

This next level, caught me off guard. It was easy... Too easy...

I don't know if the challenge creator was intentionally playing mind games with us, but after the last couple levels, I had to triple check the zip to make sure nothing was wrong.

All we have to do is extract [3.zip](files/net_matroyshka/3.zip) from the SMB2 traffic. Go to `File` -> `Export Objects` -> `SMB...` and save `/3.zip`.

#### Level 3

Now I know why the level 4 was so easy... It's because this level was just pure hell. I probably spent the most time on this part of the challenge, mostly because I had to teach myself all about the [Git Smart Protocol](https://git-scm.com/book/en/v2/Git-Internals-Transfer-Protocols) and the [git pack-format](https://git-scm.com/docs/pack-format).

First, we have to extract the packfile from the network traffic. According to the documentation, the packfile starts with the 4 byte signature `PACK`. It took me forever to realize the `PACK` signature actually shows up twice, first in packet 15 and later in packet 18.

![net_matroyshka3.jpg](img/screenshots/net_matroyshka3.jpg)

![net_matroyshka4.jpg](img/screenshots/net_matroyshka4.jpg)

I'm not sure what was going on there. For whatever reason, wireshark was just showing it weirdly. Regardless, once I realized this, it made extracting the packfile a lot easier. Everything we need is contained in packets 18 and 20.

Here's the command to extract the packfile:

```bash
tshark -nr 3.pcap -Y 'frame.number == 18 or frame.number == 20' -T fields -e git.data | sed 's/,/\n/g' | cut -c 3- | xxd -r -p > 2.pack
```

Now we have to unpack the packfile. To do this, we need to be in a git repo.

```bash
mkdir level_3 && mv 2.pack level_3 && cd level_3 && git init -q
```

Now we unpack the packfile:

```bash
$ git unpack-objects < 2.pack
Unpacking objects: 100% (3/3), 24.23 KiB | 24.23 MiB/s, done.
```

Next we run `fsck` to verify the objects we just unpacked:

```bash
$ git fsck
Checking object directories: 100% (256/256), done.
notice: HEAD points to an unborn branch (master)
notice: No default references
dangling commit 9f3d8f7b17525ec77c3bcf00ce2a4b305d47c6c9
```

Looks like a dangling commit was created when we unpacked the packfile.

Let's see what's in it:

```bash
$ git checkout 9f3d8f7b17525ec77c3bcf00ce2a4b305d47c6c9
$ ls
2.pack  2.zip
```

 [2.zip](files/net_matroyshka/2.zip)!

#### Level 2

Here we have a ton of DNS traffic. Naturally, we assume DNS data exfiltration. We can clearly see from the DNS queries that the tool used to generate this traffic was [dnscat2](https://github.com/iagox86/dnscat2), which confirms our DNS exfil theory.

![net_matroyshka5.jpg](img/screenshots/net_matroyshka5.jpg)

First things first, we need to find out where the zip is hiding. Using the filter `dns.flags.response == 1`, we *CTRL+F* for the zip file signature using the string `504b0304`. No luck. Maybe it got cut off? Let's try `504b03`. Aaaaand there it is. The zip file starts at packet 280. Next, we repeat the last step but with the *End of Central Directory Record* signature, `504b0506`. Cool, signature found in packet 416. Now we just have to make sure we don't accidentally cut off the end of the central directory record. Fortunately, it looks like everything is contained in the same packet.

![net_matroyshka6.jpg](img/screenshots/net_matroyshka6.jpg)

Great. Now let's extract the file. We only care about the hex-encoded subdomains, so we have to remember to remove the `.c2.challenges.bsidessf.net`s and ignore the `.`s. The zip also doesn't start at the beginning of the packet so we can trim off the excess 28 bytes with `tail -c +29`.

```bash
tshark -nr 2.pcap -Y "dns.flags.response == 1 && (frame.number >= 280 && frame.number <= 416)" -T fields -e dns.cname -e dns.mx.mail_exchange -e dns.txt | sed -E "s/(\t|\.c2\.challenges\.bsidessf\.net|\.)//g" | xxd -r -p | tail -c +29 > 1.zip
```

Seems easy enough... Right?

```bash
$ unzip fail.zip
Archive:  fail.zip
warning [fail.zip]:  612 extra bytes at beginning or within zipfile
  (attempting to process anyway)
error [fail.zip]:  start of central directory not found;
  zipfile corrupt.
  (please check that you have transferred or created the zipfile in the
  appropriate BINARY mode and that you have compiled UnZip properly)
```

Welp... We messed something up.

Let's manually inspect the data to see if we notice anything:

```bash
$ tshark -nr 2.pcap -Y "dns.flags.response == 1 && (frame.number >= 280 && frame.number <= 416)" -T fields -e dns.cname -e dns.mx.mail_exchange -e dns.txt | sed -E "s/(\t|\.c2\.challenges\.bsidessf\.net|\.)//g"
aebf011e5b98fff51d00001850000200042f746d702f312e7a697000504b0304140000000800a3b34f520b310cd09f1700004250000006001c00312e706361705554090003b2f52a60b2f52a6075780b000104000000000400000000
514b011e5b9952f51dd4dc79781455ba06f0ea0402e9d029c212402234011546b2874402b20712080124ec0998a5933424e998ee90c0b820a8d7ab202020c8a280ec061750071115c425a0882ba38ea3e2c6260aa2231262dfeffd62
fd9c011e5b99a5f51dd5749d9c39cf7dee7f779ea7c140f8d5fb9e3a555d75aa331f1ddeb329486ba1fdfb7f2d341bfdbaecd25f6efdfd481b6d34fd375ec36cf6055a30ff6a6bada5b7d50646de38441b12a2df417f1284bfababd03a9ddff4f36c181b83fcbd7fff44d3825ab45cdc22a8b5bd4fd77b
...
714e011e5bb081f51d62b20be65c51fc9b02af95764c2bfe40ae1fbdad587f869bec8779722cbe9cae72ceb696d327173b98c3e6aecad9860b71ea4c7b2d14ddfbc56ba5ddada57ce494294aa9f67e6d8c43855838175f34f9c66389
18fa011e5bb0d4f51d8c7512c3b7a093d1ca408578aa8bd18c25e391ac937a43adb58c56e61f504b01021e03140000000800a3b34f520b310cd09f17000042500000060018000000000000000000a48100000000312e706361705554
d1bf011e5bb127f51d050003b2f52a6075780b000104000000000400000000504b050600000000010001004c000000df1700000000
```

Each line seemed to start with a similar sequence of bytes. It looks like `dnscat2` adds some overhead bytes to each line before sending, which I would have known if I had bothered to read the [documentation](https://github.com/iagox86/dnscat2/blob/master/doc/protocol.md).

With a bit of tinkering, we get this:

```bash
tshark -nr 2.pcap -Y "dns.flags.response == 1 && (frame.number >= 280 && frame.number <= 416)" -T fields -e dns.cname -e dns.mx.mail_exchange -e dns.txt | sed -E "s/(\t|\.c2\.challenges\.bsidessf\.net|\.)//g" | cut -c 19- | xxd -r -p | tail -c +20 > 1.zip
```

There's our [1.zip](files/net_matroyshka/1.zip).

#### Level 1

After what felt like forever, I finally got to the last level. I was so excited to see that it was just some simple Telnet traffic. Follow the TCP stream and you can see a hex-encoded string being written to `flag.txt`. Decode the string to get the flag.

```bash
$ echo -e $(tshark -nr 1.pcap -Y "frame.number == 115" -T fields -e telnet.data)
CTF{baby_wireshark_doo_doo_doo_baby_wireshark}
```

![Success](img/media/success_kid.jpg)

### References

[The structure of a PKZip file](https://users.cs.jmu.edu/buchhofp/forensics/formats/pkzip.html)\
[Trivial File Transfer Protocol](https://en.wikipedia.org/wiki/Trivial_File_Transfer_Protocol#Details)\
[Git pack-format](https://git-scm.com/docs/pack-format)\
[Git Internals - Transfer Protocols](https://git-scm.com/book/en/v2/Git-Internals-Transfer-Protocols)\
[dnscat2 protocol](https://github.com/iagox86/dnscat2/blob/master/doc/protocol.md)

---

## Résumé

![Solves: 56](https://img.shields.io/badge/Solves-56-brightgreen) ![Points: 101](https://img.shields.io/badge/Points-101-blue)

**Challenge Category**

![101](https://img.shields.io/badge/101-yellow) ![Forensics](https://img.shields.io/badge/Forensics-orange)

**Challenge Description**

```
Can you get the id value from the resume?

(author: Ron)
```

**Challenge Files**

[Résumé](files/resume/resume.pdf)

**Flag**

```
CTF{shrieeeeeeeeeeeeeeeeeeeeeek}
```

### Solution

Open the PDF in Adobe. Copy the text under the black bar next to `ID:`. Paste it into a text document.

![resume1.jpg](img/screenshots/resume1.jpg)

---

## Shout into Void

![Solves: 27](https://img.shields.io/badge/Solves-27-brightgreen.svg) ![Points: 123](https://img.shields.io/badge/Points-123-blue.svg)

**Challenge Category**

![Cloud](https://img.shields.io/badge/Cloud-skyblue)

**Challenge Description**

```
All the thoughts I share are safe, for they are sucked into the void. They are never stored, so I can shake off those pesky detectives on my trail.

https://booming-cosine-304921.wl.r.appspot.com/

(author: itsc0rg1)
```

**Flag**

```
CTF{Aud1t_th3_l0g5}
```

### Summary

Site contains a hidden `.git` directory, which contains a `gcloud` service account authentication key. Use the key to authenticate and read the logs. Logs will reveal a link to `https://storage.googleapis.com/shout-into-void/1574AB2CB00533975094D87814BCF8FA707FD608-flag.txt` which contains the flag.

### Solution

We start off by visiting the site.

![shout_into_void1.jpg](img/screenshots/shout_into_void1.jpg)

We immediately find that this site has an exposed `.git` using a browser extension called `DotGit`, which automatically scans for `.git` directories.

![shout_into_void2.jpg](img/screenshots/shout_into_void2.jpg)

We also find out using `Wappalyzer` that this site is running on `Google App Engine`. That will be important later.

![shout_into_void3.jpg](img/screenshots/shout_into_void3.jpg)

After we download the `.git` and unzip it, we check the logs to see if there is anything interesting.

```bash
$ git log
commit 8170c6c35cccffe0f9e2715fd7b81c832e5d9fd1
Author: corgi <corgi@corgiwoofwoof.com>
Date:   Fri Mar 5 19:55:42 2021 -0800

    clean up complete

commit 543e9d358dbd4276da5277291624d16fb8b9d56a
Author: corgi <corgi@corgiwoofwoof.com>
Date:   Fri Mar 5 19:55:00 2021 -0800

    remove this later
```

Let's see what they mean by `remove this later`.

```bash
$ git checkout 543e9d358dbd4276da5277291624d16fb8b9d56a
Note: switching to '543e9d358dbd4276da5277291624d16fb8b9d56a'.
...
HEAD is now at 543e9d3... remove this later
$ ls
booming-cosine-304921-5327fdaff786.json
```

Let's check the contents of this json.

```bash
{
  "type": "service_account",
  "project_id": "booming-cosine-304921",
  "private_key_id": "5327fdaff786b034f9dc37834326fd83dfa1d972",
  "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC3WdABLkMR+CUr\n3M5X499SVbZWQp3WnAg1WlODyGhcntNrOK04DLpPjwNkTlM8aVjEZb6/MsNiAIbq\n11x2FF+Eblhz4IQcGjSBD6uKEud/J/2sZmePEfX7KkdEzPX9MMeajwSh+2DOJjjG\nb/iArIvVur55CGEvhwaNoBe3P/Oc/9m/tqolNYnhpBeCtiTc55/vG2PFzsHtmof1\n5sayhZ9+HQ5aUOUKvJiP9J0Ox7XUakSsF/lTNOW9eyIqleNE++bgMztISdMq325H\nlHIwC7khrZZMc6s/yhoNYaC2RxxUQQYUJpVyCfdma3a5nwXL5vbEFHSdcDEcJT0F\nIP6CLb/5AgMBAAECggEAEdQBVkQN0H78+k1foQsuyV49OxkCKP6GC84LJdrETxFA\nhIH/0d3m9dp1nXjCPjMOJxavm/7PIcXkWIx1WKP1f7aNEkNoBSWFKnGAIA5jhSk5\n0NwqQK6h6Pi88lMtrh9ioUQ70pZTXOg5iA4WL0jX1gHxCGrIrGroN7gz5iUpRoAt\n0UOiRtM8o8FO55W2hp6G+8RPCSGkBE1/z4ULjID6z4meTKfWoh2hwwGqmY0Hvxo5\nzF87qwNPDdFxg3YMBoYU4lFvyqBs3V2OyAu9GhaLU5IXMIGlnXmrndaIMrrqI9JF\nBMyaF5bGUuMeGtoimEnFuz7hd2FhX0a6fjYJioreywKBgQD1fxTJXIGHAt+145dt\nkyMfhoLSjRDc1uopkpX3Z0ZAEvXPC9BxGka1EZudrybaYv9eAJjLVFquJ9DWOa8D\nA9HNEf3Uled7QeW1JltXDLDAMF6HtB72Dz6n0kq4bgw3aPL2FykI2cgKYcEmoSCK\nr1lE7ywCVOFjisRiMaZ71rulHwKBgQC/Mg03uByAaPFjad3QCo3ISSEKpVI/E9sr\nBsipeC3x/NeXbzJdpTTfysdoYEQRDE3hXPpoVhu3RKhBLbiEb+vL+Z9P1gdVKqkr\n0YURBYV1WkNbOGzjBYxtP8N8yi8WtCGodezcoYrxbkLorCixxPuGmu80/Vc775Q+\nrXQ2mYMf5wKBgE5AlcWhoQACIID/7NLWpcl0vNqUcJ2UO8vIl9jmqHPgF05J+8Ux\nlPw+gpX+sKnICJJUKmAVoVoGAwFmHa0eWI+/fmN27PRTCv91HIRg3S5FvLwQ5BWW\nwmgIFh03ptk6sMdUlpXlpWf5xPGlRpQuVIwumJ6do8JxBywtm126EtINAoGAXsAR\nKNHG3iQjrB6k3Bq+1MjY5Qu0zKmsbZA5FTMHoeqpdNSYYywiHd3CIInEcaZlWg/X\n0KkLpzERKOvdi1RjyHv2ZXwtuhkgKST2Cs9vqg6HXseBvqfbRbDZ0hfoahnurCt0\nrIop7yezZNcce6yg8b4KWXpLJtq93qna88vz3XUCgYEAvstcvikcOvIdnhv0ukjn\ncHnHcI3NS64Ucqf8I0EPGMxRu1+3eJhfshgSPCZiefcDrLn4OOjkfwSP3tDgyhMr\ngOmXkSJo3yWUEOzbZHhsqZAvOEiaszOvmNZypTPB9vI5VQFLnaZfOnpKdexMqPQL\n9Murl5ZfjGgmctmY2N5B3Ew=\n-----END PRIVATE KEY-----\n",
  "client_email": "shout-into-void-sa@booming-cosine-304921.iam.gserviceaccount.com",
  "client_id": "107706400735285344688",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/shout-into-void-sa%40booming-cosine-304921.iam.gserviceaccount.com"
}
```

This is a service account key for a `Google App Engine` account. Now we can [authenticate](https://cloud.google.com/sdk/gcloud/reference/auth/activate-service-account) to the account and poke around.

```bash
$ gcloud auth activate-service-account  shout-into-void-sa@booming-cosine-304921.iam.gserviceaccount.com --key-file=booming-cosine-304921-5327fdaff786.json --project=booming-cosine-304921
Activated service account credentials for: [shout-into-void-sa@booming-cosine-304921.iam.gserviceaccount.com]
```

After a bit of digging around, we see this:

```bash
$ gcloud logging logs list
NAME
projects/booming-cosine-304921/logs/%2Fvar%2Flog%2Fgoogle_init.log
projects/booming-cosine-304921/logs/%2Fvar%2Flog%2Fnginx%2Ferror.log
projects/booming-cosine-304921/logs/appengine.googleapis.com%2Frequest_log
projects/booming-cosine-304921/logs/cloudaudit.googleapis.com%2Factivity
projects/booming-cosine-304921/logs/cloudaudit.googleapis.com%2Fdata_access
projects/booming-cosine-304921/logs/cloudaudit.googleapis.com%2Fsystem_event
projects/booming-cosine-304921/logs/cloudbuild
projects/booming-cosine-304921/logs/stderr
```

This `appengine` log looks interesting. Let's see what's in it:

```bash
$ gcloud logging read logName=projects/booming-cosine-304921/logs/appengine.googleapis.com%2Frequest_log
...
  resource: /send?message=https%3A%2F%2Fstorage.googleapis.com%2Fshout-into-void%2F1574AB2CB00533975094D87814BCF8FA707FD608-flag.txt
...
```

The log is really long, but that's because there's a script running every minute to get this resource:\
`/send?message=https%3A%2F%2Fstorage.googleapis.com%2Fshout-into-void%2F1574AB2CB00533975094D87814BCF8FA707FD608-flag.txt`

That leads us to a text file containing the flag.

```bash
$ curl https://storage.googleapis.com/shout-into-void/1574AB2CB00533975094D87814BCF8FA707FD608-flag.txt
CTF{Aud1t_th3_l0g5}
```

### References

[gcloud documentation](https://cloud.google.com/sdk/gcloud/reference/auth/activate-service-account)

---

## Thin Mint

![Solves: 164](https://img.shields.io/badge/Solves-164-brightgreen) ![Points: 101](https://img.shields.io/badge/Points-101-blue)

**Challenge Category**

![101](https://img.shields.io/badge/101-yellow) ![Web](https://img.shields.io/badge/Web-brightgreen)

**Challenge Description**

```
Only the admin can view the flag, what now?

https://thinmint-baeaa80f.challenges.bsidessf.net

(author: itsc0rg1)
```

**Flag**

```
CTF{iAmAdm1n}
```

### Solution

When we connect to the site, we see this:

![thin_mint1.jpg](img/screenshots/thin_mint1.jpg)

Let's check the cookies:

![thin_mint2.jpg](img/screenshots/thin_mint2.jpg)

The `tm_admin` cookie seems easy enough. We just have to change that value to a `1`. But what's this value in the `tm_user` field?

![thin_mint3.jpg](img/screenshots/thin_mint3.jpg)

Looks like it's the md5 hash for `anonymous`. What happens when we change the `tm_user` value to the md5 hash for `admin`, which is `21232f297a57a5a743894a0e4a801fc3`?

![thin_mint4.jpg](img/screenshots/thin_mint4.jpg)

---

## Unidecode

![Solves: 67](https://img.shields.io/badge/Solves-67-brightgreen) ![Points: 101](https://img.shields.io/badge/Points-101-blue)

**Challenge Category**

![101](https://img.shields.io/badge/101-yellow) ![Forensics](https://img.shields.io/badge/Forensics-orange)

**Challenge Description**

```
To maximize portability we've added Unicode support to this challenge!

(author: symmetric)
```

**Challenge Files**

[flag.jpg.utf8](files/unidecode/flag.jpg.utf8)

**Flag**

```
CTF{utf8_is_a_binary_encoding_format}
```

### Solution

For this challenge, we are given a file, [flag.jpg.utf8](files/unidecode/flag.jpg.utf8). Given the name of the file, we can assume it was encoded with utf-8. All we should have to do is decode it and render the image. We can use [CyberChef](https://gchq.github.io/CyberChef/#recipe=Decode_text('UTF-8%20(65001)')Render_Image('Raw')) to do this for us.

![flag.jpg](files/unidecode/flag.jpg)

---

## Whole New Me

![Solves: 5](https://img.shields.io/badge/Solves-5-brightgreen) ![Points: 916](https://img.shields.io/badge/Points-916-blue)

**Challenge Category**

![Cloud](https://img.shields.io/badge/Cloud-skyblue)

**Challenge Description**

```
The new me is better than the me from the past. No more flaws and no more issues - https://bustling-bay-304920.wl.r.appspot.com/

(author: itsC0rg1)
```

**Flag**

```
CTF{App3ng1n3_V3rs10n1ng}
```

### Summary

Google App Engine allows you to run multiple versions of your projects at the same time. You can access access other versions by going to `https://VERSION_ID-dot-default-dot-PROJECT_ID.REGION_ID.r.appspot.com`. The default `VERSION_ID` is the timestamp of when that version was created, in the following format: `YYYYMMDDtHHDDmmss`. I wrote a quick script to check every version until we got the flag.

### Solution

Here's what we see when we connect to the site:
![whole_new_me1.jpg](img/screenshots/whole_new_me1.jpg)

While inspecting the source code, we see this:
![whole_new_me2.jpg](img/screenshots/whole_new_me2.jpg)

It looks like the source code was modified to hide a secret, presumably the flag. So how do we get to this previous version? Using the `Wappalyzer` extension, we see that this site is running on [Google App Engine](https://cloud.google.com/appengine).

According to Google's [documentation](https://cloud.google.com/appengine/docs/flexible/nodejs/testing-and-deploying-your-app#testing-on-app-engine), you can view previous versions by going to `https://VERSION_ID-dot-default-dot-PROJECT_ID.REGION_ID.r.appspot.com`. All we need now is to find out what the default `VERSION_ID` format is. I created an account using the free trial and deployed a test app to find out the default `VERSION_ID`, which is the timestamp of when that version was created, in this format: `YYYYMMDDtHHDDmmss`.

Great, now we know everything we need to know in order to solve this challenge.

If we look back at the homepage, we see:

![whole_new_me3.jpg](img/screenshots/whole_new_me3.jpg)

This seems like a good time to use for our initial timestamp.

I wrote a quick [script](files/whole_new_me/whole_new_me.py) to check every single `VERSION_ID` starting from that time.

```python
#!/usr/bin/env python3
import re
import datetime
import requests


comment = '<!-- Corgi fix: remove the secret -->'
flag_format = re.compile('CTF\{.+\}')


if __name__ == '__main__':
    date = datetime.datetime(2021, 2, 28, 13, 52)
    while True:
        date = date - datetime.timedelta(seconds=1)
        version_id = date.strftime('%Y%m%dt%H%M%S')
        url = f'https://{version_id}-dot-bustling-bay-304920.wl.r.appspot.com/'
        try:
            r = requests.get(url)
        except Exception as e:
            print('Error occurred while retrieving page: ', url)
            print(e)

        if (flag_format.search(r.text)) or (comment not in r.text):
            source = r.text
            print(f'Interesting results found at: {url}')
            if matches := flag_format.findall(r.text):
                for match in matches:
                    print(match)
            break

        # Sanity check to see where you're at
        if date.minute == 0:
            print(date)

        if date < datetime.datetime(2021, 2, 20):
            print('Too many failed attempts. Try modifying script.')
            break
```

```bash
$ ./whole_new_me.py
Interesting results found at: https://20210228t135033-dot-bustling-bay-304920.wl.r.appspot.com/
CTF{App3ng1n3_V3rs10n1ng}
```

### References

[Testing on App Engine](https://cloud.google.com/appengine/docs/flexible/nodejs/testing-and-deploying-your-app#testing-on-app-engine)

---

## Xoray

![Solves: 37](https://img.shields.io/badge/Solves-37-brightgreen) ![Points: 102](https://img.shields.io/badge/Points-102-blue)

**Challenge Category**

![101](https://img.shields.io/badge/101-yellow) ![Crypto](https://img.shields.io/badge/Crypto-blue)

**Challenge Description**

```
Peer beyond the encryption to the hidden structure!

(author: symmetric)
```

**Challenge Files**

[xoray.bin](files/xoray/xoray.bin)

**Flag**

```
CTF{this_is_why_k4_remains_unsolved}
```

### Solution

For this challenge, we are given a file, [xoray.bin](files/xoray/xoray.bin). From the name of the file, we can guess it is likely encrypted with a repeating key XOR. We can use a tool called [xortool](https://github.com/hellman/xortool) to decrypt the file. First we have to find out the most likely key length:

```bash
$ xortool xoray.bin
The most probable key lengths:
 2:   7.8%
 4:  10.8%
 6:   6.6%
 8:  15.9%
10:   5.5%
12:   7.4%
16:  20.7%
24:   7.7%
32:  10.9%
48:   6.7%
Key-length can be 4*n
Most possible char is needed to guess the key!
```

The key length with the highest score is 16, so we'll try that first. Next we attempt to decrypt the file by brute forcing the key using the key length `16`. We can filter by the flag format, `CTF`, to narrow down the amount of results:

```bash
$ xortool -l 16 -b -p 'CTF' xoray.bin
256 possible key(s) of length 16:
\xe1C\x92\xb4\xd6T\xd9:\xbef\x9eA0\x10\xa5\x86
\xe0B\x93\xb5\xd7U\xd8;\xbfg\x9f@1\x11\xa4\x87
\xe3A\x90\xb6\xd4V\xdb8\xbcd\x9cC2\x12\xa7\x84
\xe2@\x91\xb7\xd5W\xda9\xbde\x9dB3\x13\xa6\x85
\xe5G\x96\xb0\xd2P\xdd>\xbab\x9aE4\x14\xa1\x82
...
Found 1 plaintexts with 95%+ valid characters which contained 'CTF'
See files filename-key.csv, filename-char_used-perc_valid.csv
```

Looks like we've found a match. Let's check the output for any matches to the flag format:

```bash
$ egrep -r 'CTF\{.+\}' xortool_out/
xortool_out/032.out:    CTF{this_is_why_k4_remains_unsolved}
```
